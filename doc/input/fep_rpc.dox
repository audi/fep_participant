/**
 *
 * This file describes the usage of the fep rpc service
 *
 * @file
 * Copyright @ 2019 Audi AG. All rights reserved.
 * 
 *     This Source Code Form is subject to the terms of the Mozilla
 *     Public License, v. 2.0. If a copy of the MPL was not distributed
 *     with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 * 
 * If it is not possible or desirable to put the notice in a particular file, then
 * You may include the notice in a location (such as a LICENSE file in a
 * relevant directory) where a recipient would be likely to look for such a notice.
 * 
 * You may add additional accurate notices of copyright ownership.
 *
 */

namespace fep
{

/**
\page fep_rpc FEP Remote Procedure Call (RPC)

The FEP RPC interface offers the possibility to serve and consume arbitrary interfaces remotely
(Remote Procedure Call), within the FEP %System.

It can be used to implement functionality in FEP Participants which does not map to FEP signals
(which are only available during FS_RUNNING) and which is directed to individual elements (no
broadcast).

FEP RPC is available during all FEP states except FS_SHUTDOWN.

FEP RPC is divided into two roles: the \ref fep_rpc_server and the \ref fep_rpc_client. One server
implements and serves the API interface, many clients connect to the server and issue calls into the
API interface.

An example of a server and a client can be found here \ref page_demo_service.

FEP RPC is based on the JSON-RPC service.  JSON-RPC (JavaScript Object Notation Remote Procedure
Call) is an open protocol for calling remote methods in computer systems.  The implementation is
fully <a href="http://www.jsonrpc.org/specification">JSON_RPC 2.0</a> compatible.

\section fep_rpc_usage Interface description and code generation

The interface served in the server and consumed in the client, is described by means of a JSON
interface description.  For an example see \ref page_demo_service and the JSON-RPC documentation.

The client and server stubs are generated automatically from the JSON interface description during
build time with the help of the CMake macros
<code>jsonrpc_generate_client_stub(JSON_RPC_DEFINITION_FILE CLIENT_CLASS_NAME
CLIENT_FILE_NAME)</code> and <code>jsonrpc_generate_server_stub(JSON_RPC_DEFINITION_FILE
SERVER_CLASS_NAME SERVER_FILE_NAME)</code>.
 - The JSON_RPC_DEFINITION_FILE is the path to the JSON interface description file.
 - The CLIENT_CLASS_NAME / SERVER_CLASS_NAME is the fully qualified C++ class name of the RPC stub that is generated.
 - The CLIENT_FILE_NAME / SERVER_FILE_NAME is the path where the generated code is stored.

The code generated in this way must then be included via \#include.

\section fep_rpc_server RPC Server

To implement the server functions declared in the JSON description, create a class that inherits
from \ref fep::rpc_object_server and implement the abstract methods of the generated server stub.
\ref fep::rpc_object_server takes the implementation generated by CMake as its first template
argument. In addition, each server requires a unique ID and name, so that servers can be found and
distinguished by clients. Specify ID and default name in an extra interface class - use the \ref
FEP_RPC_IID macro - and pass this interface as second argument to \ref fep::rpc_object_server.

Instantiate the server object and register it for the fep system.  It is possible to register
multiple instances of the same server in the system and have client requests answered by different
instances of this server.  \note As long as the server is registered, its instance must be
available.

\subsection fep_rpc_server_registration Registering the server

A server can be registered in the system using the RPC Protocol Object Registry \ref
fep::IRPCObjectServerRegistry which can be accessed via the RPC Access Interface \ref fep::IRPC of a
FEP module.

It is also possible to register the server using an \ref AutomationInterface "FEP Automation
Interface" instance, in cases where no "real" FEP Participant is available.

\section fep_rpc_client RPC Client

To send requests to an RPC server a \ref fep::rpc_object_client instance is required. Its first
template argument is the client stub generated by CMake. The second template argument is the Server
ID interface class.

The client provides the methods for sending requests to a server and returns the server response.
Client server communication is synchronous. The returned data from the server is provided as return
value of the request method. Answers that include only a single C type are returned directly,
multiple values are returned encoded in a Json::Value. The return code can be retrieved from the
Json::Value using rpc::cJSONConversions::json_to_result. If errors occur during communication with
the server, an exception is thrown. A possible error can be, that the client runs into a timeout.
The default waiting time of an RPC client is 5000 ms. There is also a possibility to change this
value by manipulating the FEP PropertyTree entry \c ComponentConfig.RPCClient.nTimeoutMS.

\note A client request may throw exceptions of type jsonrpc::JsonRpcException.

*/
}
